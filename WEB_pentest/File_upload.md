# FILE UNPLOAD VULN

**1. Absent validation**
no validation implemented, but before uploading any webshell script check what are the programming language running on the server, then upload the webshell in that programming language.
**To check the programing language**
- try navigating to the index page and see in which extension it give us the same page.
- extension - `Wappalyzer`
- `burp fuzzzing` and `Fuff tool`

test the vulnerability by uploading the arbatiry files.
then upload the webshell to exploit it.


# Client-Side Validation

1. the file format validation is happening on the client-side, we can easily bypass it by directly interacting with the server, skipping the front-end validations altogether. We may also modify the front-end code through our browser's dev tools to disable any validation in place.
2. we can use burp also capture the request and modify it to bypass the client side validation
3. or disable the validation from the html code of the page because client side is using only javascript to validate.

# Blacklisted list

The code is taking the file extension ($extension) from the uploaded file name ($fileName) and then comparing it against a list of blacklisted extensions ($blacklist). However, this validation method has a major flaw. It is not comprehensive, as many other extensions are not included in this list, which may still be used to execute PHP code on the back-end server if uploaded.

The comparison above is also case-sensitive, and is only considering lowercase extensions. In Windows Servers, file names are case insensitive, so we may try uploading a php with a mixed-case (e.g. pHp), which may bypass the blacklist as well, and should still execute as a PHP script.

type:
Testing against a blacklist of types - means some of the extensions are not allowed to the system to perform cmd ececution 

**Bypass**
to bypass this we need to fuzz for the extensions and fine which one is allowed and executng cmd on the web application system.

# whitelisted list

2. Testing against a whitelist of types - list of all allowed extensions only and other are blocked.
**Bypass**
here we need to find the allowed extensions and the validation. and we can use double extension
- double extension
- reverse double extension
- character injection
code to make all extensions with all combination 

    for char in '%20' '%0a' '%00' '%0d0a' '/' '.\\' '.' 'â€¦' ':'; do
        for ext in '.php' '.phps'; do
            echo "shell$char$ext.jpg" >> wordlist.txt
            echo "shell$ext$char.jpg" >> wordlist.txt
            echo "shell.jpg$char$ext" >> wordlist.txt
            echo "shell.jpg$ext$char" >> wordlist.txt
        done
    done


# **Type Filters**
many modern web servers and web applications also test the content of the uploaded file to ensure it matches the specified type. While extension filters may accept several extensions, content filters usually specify a single category (e.g., images, videos, documents)

There are two common methods for validating the file content: Content-Type Header or File Content. 

**1. Content-Type**

![Content-type](image-10.png)

**Note:** A file upload HTTP request has two Content-Type headers, one for the attached file (at the bottom), and one for the full request (at the top). We usually need to modify the file's Content-Type header, but in some cases the request will only contain the main Content-Type header (e.g. if the uploaded content was sent as POST data), in which case we will need to modify the main Content-Type header.


**MIME-Type**
file content validation is testing the uploaded file's MIME-Type. Multipurpose Internet Mail Extensions (MIME) is an internet standard that determines the type of a file through its general format and bytes structure.

![file type](image-11.png)

we can try using an Allowed MIME type with a disallowed Content-Type, an Allowed MIME/Content-Type with a disallowed extension, or a Disallowed MIME/Content-Type with an allowed extension, and so on. Similarly, we can attempt other combinations and permutations to try to confuse the web server, and depending on the level of code security, we may be able to bypass various filters.

# Limited File Uploads
file types, like SVG, HTML, XML, and even some image and document files, may allow us to introduce new vulnerabilities to the web application by uploading malicious versions of these files. This is why fuzzing allowed file extensions is an important exercise for any file upload attack. It enables us to explore what attacks may be achievable on the web server. So, let's explore some of these attacks.

**XSS**
Many file types may allow us to introduce a Stored XSS vulnerability to the web application 
we can include an XSS payload in one of the Metadata parameters that accept raw text, like the Comment or Artist parameters, as follows:

    exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg    #using exiftool
    
    htb2.jpg  #usign svg image
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
        <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
        <script type="text/javascript">alert(window.origin);</script>
    </svg>

**XXE**

XXE exploitation. With SVG images, we can also include malicious XML data to leak the source code of the web application, and other internal documents within the server.

    #read system files 
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
    <svg>&xxe;</svg>

    #read the source code if webspplication runing on php
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
    <svg>&xxe;</svg>

Using XML data is not unique to SVG images, as it is also utilized by many types of documents, like PDF, Word Documents, PowerPoint Documents, among many others. In that case, we may also modify their XML data to include the malicious XXE elements, and we would be able to carry a blind XXE attack on the back-end web server.

**DoS**

Many file upload vulnerabilities may lead to a Denial of Service (DOS) attack on the web server.

1. we can utilize a Decompression Bomb with file types that use data compression.
2.  DoS attack is a Pixel Flood attack with some image files that utilize image compression, size 500x500 to 0xffff x 0xffff
3. One way is uploading an overly large file
4. If the upload function is vulnerable to directory traversal, we may also attempt uploading files to a different directory (e.g. ../../../etc/passwd), which may also cause the server to crash. 

# OTHER UPLOAD ATTACK
A common file upload attack uses a malicious string for the uploaded file name, which may get executed or processed if the uploaded file name is displayed (i.e., reflected) on the page. We can try injecting a command in the file name, and if the web application uses the file name within an OS command, it may lead to a command injection attack. eg: `file$(whoami).jpg` or  file`whoami`.jpg or `file.jpg||whoami`

we may use an XSS payload in the file name (e.g. `<script>alert(window.origin);</script>`),

We may also inject an SQL query in the file name (e.g. file';select+sleep(5);--.jpg),

**Upload Directory Disclosure**

# Prevention
**Extension Validation** we should make sure that our file upload functions can securely handle extension validation. whitelisting extensions is always more secure, we should also apply both back-end and front-end file validation

**Content Validation** - must always validate both the file extension and its content, It is always recommended to hide the uploads directory from the end-users and only allow them to download the uploaded files through a download page.  we should also randomize the names of the uploaded files in storage and store their "sanitized" original names in a database, Another thing we can do is store the uploaded files in a separate server or container.

