# SCRIPTING

## Execution

    bash script.sh <optional arguments>
    sh script.sh <optional arguments>
    ./script.sh <optional arguments>

**Example.sh**

    #!/bin/bash                                                                         #shebang

    # Check for given arguments
    if [ $# -eq 0 ]
    then
        echo -e "You need to specify the target domain.\n"
        echo -e "Usage:"
        echo -e "\t$0 <domain>"
        exit 1
    else
        domain=$1
    fi

    # Identify Network range for the specified IP address(es)
    function network_range {
        for ip in $ipaddr
        do
            netrange=$(whois $ip | grep "NetRange\|CIDR" | tee -a CIDR.txt)
            cidr=$(whois $ip | grep "CIDR" | awk '{print $2}')
            cidr_ips=$(prips $cidr)
            echo -e "\nNetRange for $ip:"
            echo -e "$netrange"
        done
    }

    # Ping discovered IP address(es)
    function ping_host {
        hosts_up=0
        hosts_total=0
        
        echo -e "\nPinging host(s):"
        for host in $cidr_ips
        do
            stat=1
            while [ $stat -eq 1 ]
            do
                ping -c 2 $host > /dev/null 2>&1
                if [ $? -eq 0 ]
                then
                    echo "$host is up."
                    ((stat--))
                    ((hosts_up++))
                    ((hosts_total++))
                else
                    echo "$host is down."
                    ((stat--))
                    ((hosts_total++))
                fi
            done
        done
        
        echo -e "\n$hosts_up out of $hosts_total hosts are up."
    }

    # Identify IP address of the specified domain
    hosts=$(host $domain | grep "has address" | cut -d" " -f4 | tee discovered_hosts.txt)

    echo -e "Discovered IP address:\n$hosts\n"
    ipaddr=$(host $domain | grep "has address" | cut -d" " -f4 | tr "\n" " ")

    # Available options
    echo -e "Additional options available:"
    echo -e "\t1) Identify the corresponding network range of target domain."
    echo -e "\t2) Ping discovered hosts."
    echo -e "\t3) All checks."
    echo -e "\t*) Exit.\n"

    read -p "Select your option: " opt

    case $opt in
        "1") network_range ;;
        "2") ping_host ;;
        "3") network_range && ping_host ;;
        "*") exit 0 ;;
    esac


## Only if 

    #!/bin/bash

    value=$1

    if [ $value -gt "10" ]
    then
            echo "Given argument is greater than 10."
    fi

## if-else (nested)

    #!/bin/bash

    value=$1

    if [ $value -gt "10" ]
    then
        echo "Given argument is greater than 10."
    elif [ $value -lt "10" ]
    then
        echo "Given argument is less than 10."
    else
        echo "Given argument is not a number."
    fi

## Arguments

    Keshri@htb[/htb]$ ./script.sh ARG1 ARG2 ARG3 ... ARG9
        ASSIGNMENTS:       $0      $1   $2   $3 ...   $9
    
IFS	|Description
|-|-|
`$#`|	This variable holds the number of arguments passed to the script.
`$@`|	This variable can be used to retrieve the list of command-line arguments.
`$n`|	Each command-line argument can be selectively retrieved using its position. For example, the first argument is found at $1.
`$$`|	The process ID of the currently executing process.
`$?`|	The exit status of the script. This variable is useful to determine a command's success. The value 0 represents successful execution, while 1 is a result of a failure.


IFS|	Description
|-|-|
`$#`|	In this case, we need just one variable that needs to be assigned to the domain variable. This variable is used to specify the target we want to work with. If we provide just an FQDN as the argument, the $# variable will have a value of 1.
`$0`|	This special variable is assigned the name of the executed script, which is then shown in the "Usage:" example.
`$1`|	Separated by a space, the first argument is assigned to that special variable.


## Variable

    Keshri@htb[/htb]$ variable="Declared without an error."
    Keshri@htb[/htb]$ echo $variable

## Arrays

    #!/bin/bash

    domains=(www.inlanefreight.com ftp.inlanefreight.com vpn.inlanefreight.com www2.inlanefreight.com)

    echo ${domains[0]}

    #www.inlanefreight.com

## Comparison Operators

string operators
integer operators
file operators
boolean operators

Operator	Description
==	is equal to
!=	is not equal to
<	is less than in ASCII alphabetical order
>	is greater than in ASCII alphabetical order
-z	if the string is empty (null)
-n	if the string is not null


Operator	Description
-eq	is equal to
-ne	is not equal to
-lt	is less than
-le	is less than or equal to
-gt	is greater than
-ge	is greater than or equal to


Operator	Description
-e	if the file exist
-f	tests if it is a file
-d	tests if it is a directory
-L	tests if it is if a symbolic link
-N	checks if the file was modified after it was last read
-O	if the current user owns the file
-G	if the file’s group id matches the current user’s
-s	tests if the file has a size greater than 0
-r	tests if the file has read permission
-w	tests if the file has write permission
-x	tests if the file has execute permission


Operator	Description
!	logical negotation NOT
&&	logical AND
||	logical OR


## Arithmetic

Operator	Description
+	Addition
-	Substraction
*	Multiplication
/	Division
%	Modulus
variable++	Increase the value of the variable by 1
variable--	Decrease the value of the variable by 1

## Input and Output

    read -p "Select your option: " opt 

## Flow Control - Loops

- Branches:
    - If-Else Conditions
    - Case Statements
    - Loops:
- Loops
    - For Loops
    - While Loops
    - Until Loops

### For example


    for variable in 1 2 3 4/{1..10}/
    do
        echo $variable
    done


    for variable in file1 file2 file3
    do
        echo $variable
    done

    for ip in "10.10.10.170 10.10.10.174 10.10.10.175"
    do
        ping -c 1 $ip
    done

    for ip in 10.10.10.170 10.10.10.174;do ping -c 1 $ip;done

### while loop 

    #!/bin/bash

    counter=0

    while [ $counter -lt 10 ]
    do
    # Increase $counter by 1
    ((counter++))
    echo "Counter: $counter"

    if [ $counter == 2 ]
    then
        continue
    elif [ $counter == 4 ]
    then
        break
    fi
    done

### Until loop 
- The code inside a until loop is executed as long as the particular condition is false.

    #!/bin/bash

    counter=0

    until [ $counter -eq 10 ]
    do
    # Increase $counter by 1
    ((counter++))
    echo "Counter: $counter"
    done

### Swich case/ Case

    case <expression> in
        pattern_1 ) statements ;;
        pattern_2 ) statements ;;
        pattern_3 ) statements ;;
    esac

## Function

    #Method 1

    function name {
        <commands>
    }

    #Method2
    name() {
	    <commands>
    } 

### parameter parsing 

    #!/bin/bash

    function print_pars {
        echo $1 $2 $3
    }

    one="First parameter"
    two="Second parameter"
    three="Third parameter"

    print_pars "$one" "$two" "$three"

### return value 

Return Code	Description
1	General errors
2	Misuse of shell builtins
126	Command invoked cannot execute
127	Command not found
128	Invalid argument to exit
128+n	Fatal error signal "n"
130	Script terminated by Control-C
255\*	Exit status out of range

## Debugging 

-  Bash allows us to debug our code by using the "-x" (xtrace) and "-v" options. 
- If we want to see all the code for a particular function, we can set the "-v" option that displays the output in more detail.